(** {1 Locally shared memory model - World Theory} *)
module World
  use int.Int
  use map.Map
  use list.List
  use list.Append
  use list.Mem
  use list.Map as Lmap


  (* types to be defined at the system level,
     to be instantiated when cloning *)
  type node
  type state


  (* product types and their selectors *)
  type world =  map node state

end

(** {2 Locally shared memory model - Network Theory} *)
module Steps
  use int.Int
  use map.Map
  use list.List
  use list.Mem
  use list.Append
  use list.Map as Lmap
  use set.Fset


 

  (* types to be defined at system level, to be instantiated when cloning *)

  type node
  val predicate validNd (n:node)
  type state

  
  
  (* case analysis predicates are always true *)
  val predicate case_node (node)
    ensures { result }
  val predicate case_state (state)
    ensures { result }

  (* product types *)
  type world = map node state

  (* candidate inductive predicate
     contract ensures initial world satifies the predicate *)
  val ghost predicate indpred (w:world)
    ensures { forall w_init: world. w=w_init -> result }


  (* handleEnbld-enabling predicate, to be instantiated when cloning *)
  val ghost predicate enabled (map node state) (i:node)
    requires { validNd i }


  (* function specifying how the outputs of the handlers are used
     both in the handler's contract and in the transition relation *)
     
     
     
  function step_enbld (w:world) (n:node) (st:state) : world =
  
    set w n st

  (* handler to be executed at node h when it is enabled
     in the world lS. Preservation of the inductive predicate
     is enforced *)
  val function handleEnbld (h:node) (lS:map node state) : state
    requires { validNd h }
    requires { enabled lS h}
    requires { indpred lS }
    requires { case_node h }
    ensures  { indpred (step_enbld lS h result) }


  (* Transition semantics, in the form of an inductive invariant *)

  
    inductive step (w: world) (ns: fset node) (w': world) =
  | step_enbld: forall w: world, n: node, ns: fset node.
      validNd n ->
      enabled w n ->
      not (is_empty ns) ->
      mem n ns ->
          step w ns (step_enbld w n (handleEnbld n w))
 
 (* Essai pas ouf
 let rec ghost function step_enbld_all (w:world) (ns:fset node) : world 
     ensures { is_empty ns -> result = w }
    ensures { not (is_empty ns) -> indpred result }
    variant { cardinal ns }=
    if is_empty ns then
      w
    else
      let n = pick ns in
      let w' = step_enbld w n (handleEnbld n w) in
      step_enbld_all w' (remove n ns)
     *) 

  lemma indpred_step :
    forall w w' :world, ns :fset node. step w ns w' -> indpred w -> indpred w'

  lemma step_preserves_states :
    forall w w' :world, ns: fset node,  i :node. step w ns w' -> not(mem i ns) -> w i = w' i
    

  (* many steps relation [reflexive transitive closure]
     and reachable worlds *)
  inductive step_TR world world int =
  | base : forall w :world. step_TR w w 0
  | step : forall w w' w'' :world, ns :fset node, steps :int.
    step_TR w w' steps -> step w' ns w'' -> step_TR w w'' (steps+1)

  lemma noNegative_step_TR : forall w w' :world, steps :int.
    step_TR w w' steps -> steps >= 0

  predicate reachable (w:world) = exists steps :int. forall w_init:world. step_TR w_init w steps

  (* inductive predicate is preserved by many steps and holds
     in reachable worlds *)

  lemma indpred_manySteps :
    forall w w' :world, steps :int . step_TR w w' steps -> indpred w -> indpred w'

  lemma indpred_reachable :
    forall w :world. reachable w -> indpred w

end
